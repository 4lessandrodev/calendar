"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Aggregate = void 0;
const domain_event_1 = require("./domain-event");
const entity_1 = require("./entity");
const id_1 = require("./id");
const result_1 = require("./result");
/**
 * @description Aggregate identified by an id
 */
class Aggregate extends entity_1.default {
    constructor(props, config, events) {
        super(props, config);
        this._dispatchEventsAmount = 0;
        this._domainEvents = Array.isArray(events) ? events : [];
    }
    /**
     * @description Get hash to identify the aggregate.
     * @returns Aggregate hash as ID instance.
     * @example
     * `[Aggregate@ClassName]:UUID`
     *
     * @summary className is defined on constructor config param
     */
    hashCode() {
        const name = Reflect.getPrototypeOf(this);
        return id_1.default.create(`[Aggregate@${name?.constructor.name}]:${this.id.value()}`);
    }
    /**
     * @description Get aggregate metrics
     * @access current events as number representing total of events in state for aggregate
     * @access total as number representing total events for aggregate including dispatched
     * @access dispatch total of events already dispatched
     */
    get eventsMetrics() {
        return {
            current: this._domainEvents.length,
            total: this._domainEvents.length + this._dispatchEventsAmount,
            dispatch: this._dispatchEventsAmount
        };
    }
    /**
     * @description Get a new instanced based on current Aggregate.
     * @summary if not provide an id a new one will be generated.
     * @param props as optional Aggregate Props.
     * @param copyEvents as boolean. default: false.
     * @returns new Aggregate instance.
     */
    clone(props) {
        const _props = props ? { ...this.props, ...props } : { ...this.props };
        const _events = (props && !!props.copyEvents) ? this._domainEvents : [];
        const instance = Reflect.getPrototypeOf(this);
        const args = [_props, this.config, _events];
        const aggregate = Reflect.construct(instance.constructor, args);
        return aggregate;
    }
    /**
     * @description Dispatch event added to aggregate instance
     * @param eventName optional event name as string. If provided only event match name is called.
     * @returns Promise void as executed event
     */
    dispatchEvent(eventName, handler) {
        if (!eventName)
            return this.dispatchAll(handler);
        const callback = handler || ({ execute: () => { } });
        for (const event of this._domainEvents) {
            if (event.aggregate.id.equal(this.id) && event.callback.eventName === eventName) {
                this._dispatchEventsAmount++;
                event.callback.dispatch(event, callback);
                this.deleteEvent(eventName);
            }
        }
    }
    /**
     * @description Dispatch all events for current aggregate.
     * @param handler as EventHandler.
     * @returns promise void.
     */
    dispatchAll(handler) {
        const callback = handler || ({ execute: () => { } });
        for (const event of this._domainEvents) {
            if (event.aggregate.id.equal(this.id)) {
                this._dispatchEventsAmount++;
                event.callback.dispatch(event, callback);
            }
        }
        this._domainEvents = [];
    }
    ;
    /**
     * @description Delete all events in current aggregate instance.
     * @param config.resetMetrics reset info about events dispatched.
     * @returns void.
     */
    clearEvents(config = { resetMetrics: false }) {
        this._dispatchEventsAmount = config.resetMetrics ? 0 : this._dispatchEventsAmount;
        this._domainEvents = [];
    }
    ;
    /**
     * @description Add event to aggregate instance.
     * @param eventToAdd Event to be dispatched.
     * @param replace 'REPLACE_DUPLICATED' option to remove old event with the same name and id.
     * @emits dispatch to aggregate instance. Do not use event using global event manager as DomainEvent.dispatch
     */
    addEvent(eventToAdd, replace) {
        const doReplace = replace === 'REPLACE_DUPLICATED';
        const event = new domain_event_1.default(this, eventToAdd);
        const target = Reflect.getPrototypeOf(event.callback);
        const eventName = event.callback?.eventName ?? target?.constructor.name;
        event.callback.eventName = eventName;
        if (!!doReplace)
            this.deleteEvent(eventName);
        this._domainEvents.push(event);
    }
    /**
     * @description Delete event match with provided name
     * @param eventName event name as string
     * @returns number of deleted events
     */
    deleteEvent(eventName) {
        let deletedEventsAmount = this._domainEvents.length;
        this._domainEvents = this._domainEvents.filter(domainEvent => (domainEvent.callback.eventName !== eventName));
        return deletedEventsAmount - this._domainEvents.length;
    }
    /**
     *
     * @param props params as Props
     * @param id optional uuid as string, second arg. If not provided a new one will be generated.
     * @returns instance of result with a new Aggregate on state if success.
     * @summary result state will be `null` case failure.
     */
    static create(props) {
        if (!this.isValidProps(props))
            return result_1.default.fail('Invalid props to create an instance of ' + this.name);
        return result_1.default.Ok(new this(props));
    }
    ;
}
exports.Aggregate = Aggregate;
exports.default = Aggregate;
//# sourceMappingURL=aggregate.js.map