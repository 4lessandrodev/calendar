import { EntityProps, EventHandler, EventMetrics, IAggregate, IDomainEvent, IHandle, IReplaceOptions, IResult, ISettings, UID } from "../types";
import Entity from "./entity";
/**
 * @description Aggregate identified by an id
 */
export declare class Aggregate<Props extends EntityProps> extends Entity<Props> implements IAggregate<Props> {
    private _domainEvents;
    private _dispatchEventsAmount;
    constructor(props: Props, config?: ISettings, events?: Array<IDomainEvent<IAggregate<Props>>>);
    /**
     * @description Get hash to identify the aggregate.
     * @returns Aggregate hash as ID instance.
     * @example
     * `[Aggregate@ClassName]:UUID`
     *
     * @summary className is defined on constructor config param
     */
    hashCode(): UID<string>;
    /**
     * @description Get aggregate metrics
     * @access current events as number representing total of events in state for aggregate
     * @access total as number representing total events for aggregate including dispatched
     * @access dispatch total of events already dispatched
     */
    get eventsMetrics(): EventMetrics;
    /**
     * @description Get a new instanced based on current Aggregate.
     * @summary if not provide an id a new one will be generated.
     * @param props as optional Aggregate Props.
     * @param copyEvents as boolean. default: false.
     * @returns new Aggregate instance.
     */
    clone(props?: Partial<Props> & {
        copyEvents?: boolean;
    }): this;
    /**
     * @description Dispatch event added to aggregate instance
     * @param eventName optional event name as string. If provided only event match name is called.
     * @returns Promise void as executed event
     */
    dispatchEvent(eventName?: string, handler?: EventHandler<IAggregate<any>, void>): void;
    /**
     * @description Dispatch all events for current aggregate.
     * @param handler as EventHandler.
     * @returns promise void.
     */
    dispatchAll(handler?: EventHandler<this, void>): void;
    /**
     * @description Delete all events in current aggregate instance.
     * @param config.resetMetrics reset info about events dispatched.
     * @returns void.
     */
    clearEvents(config?: {
        resetMetrics: boolean;
    }): void;
    /**
     * @description Add event to aggregate instance.
     * @param eventToAdd Event to be dispatched.
     * @param replace 'REPLACE_DUPLICATED' option to remove old event with the same name and id.
     * @emits dispatch to aggregate instance. Do not use event using global event manager as DomainEvent.dispatch
     */
    addEvent(eventToAdd: IHandle<this>, replace?: IReplaceOptions): void;
    /**
     * @description Delete event match with provided name
     * @param eventName event name as string
     * @returns number of deleted events
     */
    deleteEvent(eventName: string): number;
    static create(props: any): IResult<any, any, any>;
}
export default Aggregate;
//# sourceMappingURL=aggregate.d.ts.map