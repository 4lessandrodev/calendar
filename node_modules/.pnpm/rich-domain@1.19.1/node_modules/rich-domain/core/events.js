"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainEvents = void 0;
const iterator_1 = require("./iterator");
/**
 * @description Domain Events manager for global events.
 * @global events for aggregates.
 * @ignore events added in instance of aggregates directly.
 */
class DomainEvents {
    /**
     * @description Add event to state.
     * @param param event to be added.
     */
    static addEvent({ event, replace }) {
        const target = Reflect.getPrototypeOf(event.callback);
        const eventName = event.callback?.eventName ?? target?.constructor.name;
        if (!!replace)
            DomainEvents.deleteEvent({ eventName, id: event.aggregate.id });
        event.callback.eventName = eventName;
        DomainEvents.events.addToEnd(event);
    }
    /**
     * @description Dispatch event for a provided name and an aggregate id.
     * @param options params to find event to dispatch it.
     * @returns promise void.
     */
    static async dispatch(options, handler) {
        const log = () => console.log('None handler provided');
        const callback = handler ? handler : ({ execute: () => { log(); } });
        const eventsToDispatch = [];
        const events = DomainEvents.events.toArray();
        let position = 0;
        while (events[position]) {
            const event = events[position];
            if (event.aggregate.id.equal(options.id) && event.callback.eventName === options.eventName) {
                eventsToDispatch.push(event);
                DomainEvents.events.removeItem(event);
            }
            position = position + 1;
        }
        eventsToDispatch.forEach((agg) => agg.callback.dispatch(agg, callback));
    }
    /**
     * @description Dispatch event for a provided name and an aggregate id.
     * @param id aggregate id.
     * @returns promise void.
     */
    static async dispatchAll(id, handler) {
        const log = () => console.log('None handler provided');
        const callback = handler ? handler : ({ execute: () => { log(); } });
        const eventsToDispatch = [];
        const events = DomainEvents.events.toArray();
        let position = 0;
        while (events[position]) {
            const event = events[position];
            if (event.aggregate.id.equal(id)) {
                eventsToDispatch.push(event);
                DomainEvents.events.removeItem(event);
            }
            position = position + 1;
        }
        eventsToDispatch.forEach((agg) => agg.callback.dispatch(agg, callback));
    }
    /**
     * @description Delete an event from state.
     * @param options to find event to be deleted.
     */
    static deleteEvent(options) {
        const events = DomainEvents.events.toArray();
        let position = 0;
        while (events[position]) {
            const event = events[position];
            const target = Reflect.getPrototypeOf(event.callback);
            const eventName = event.callback?.eventName ?? target?.constructor.name;
            if (event.aggregate.id.equal(options.id) && options.eventName === eventName) {
                DomainEvents.events.removeItem(event);
            }
            position = position + 1;
        }
    }
}
exports.DomainEvents = DomainEvents;
DomainEvents.events = iterator_1.default.create();
exports.default = DomainEvents;
//# sourceMappingURL=events.js.map