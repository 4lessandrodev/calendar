"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Iterator = void 0;
/**
 * @description Iterator allows sequential traversal through a complex data structure without exposing its internal details.
 * Make any array an iterator using this class.
 */
class Iterator {
    constructor(config) {
        this.currentIndex = -1;
        this.items = config?.initialData ?? [];
        this.lastCommand = 'none';
        this.returnCurrentOnReversion = !!config?.returnCurrentOnReversion;
        this.restartOnFinish = !!config?.restartOnFinish;
    }
    /**
     * initialData?: Array<T>;
    returnCurrentOnReversion?: boolean;
    restartOnFinish?: boolean;
     */
    /**
     *
     * @param config Iterator setup as object.
     * @param config.initialData the initial state as Array<T> to turn iterable.
     * @param config.returnCurrentOnReversion this setting allows you to return the current element when you are iterating in one direction and decide to change the iteration to the other direction.
     * @param config.restartOnFinish this configuration turns the iteration into an infinite loop, as when reaching the last element, the iteration starts over from the first element.
     * @returns instance of Iterator.
     */
    static create(config) {
        return new Iterator(config);
    }
    /**
     * @description Remove one item if found
     * @param item to be removed
     */
    removeItem(item) {
        const index = this.items.findIndex((value) => JSON.stringify(item) === JSON.stringify(value));
        if (index !== -1) {
            this.items.splice(index, 1);
            if (index >= this.currentIndex)
                this.prev();
        }
    }
    /**
     * @description This method check if has some elements after current position.
     * @returns boolean `true` if has next element and `false` if not.
     */
    hasNext() {
        if (this.isEmpty())
            return false;
        return (this.currentIndex + 1) < this.items.length;
    }
    /**
     * @description This method check if has some elements before current position.
     * @returns boolean `true` if has next element and `false` if not.
     */
    hasPrev() {
        if (this.isEmpty())
            return false;
        return (this.currentIndex - 1) >= 0;
    }
    /**
     * @description This method check if current data state is empty.
     * @returns boolean `true` if is empty and `false` if not.
     */
    isEmpty() {
        return this.total() === 0;
    }
    /**
     * @description This method get the element on current position. Alway start on first element.
     * @returns element on current position and update cursor to the next element.
     *
     * @access if param `config.restartOnFinish` is set to `true` and cursor is on last element the next one will be the first element on state, case value is set to `false` the next element will be `null`.
     */
    next() {
        if (this.hasNext()) {
            if (this.lastCommand === 'prev' && this.currentIndex === 0) {
                this.lastCommand = 'next';
                return this.items[this.currentIndex];
            }
            const next = (this.currentIndex + 1);
            this.currentIndex = next;
            this.lastCommand = this.returnCurrentOnReversion ? 'next' : 'none';
            return this.items[next];
        }
        ;
        if (!this.restartOnFinish)
            return null;
        this.toFirst();
        return this.first();
    }
    /**
     * @description This method get the element on current position. Alway start on first element.
     * @returns element on current position and update cursor to the previous element.
     *
     * @access if param `config.restartOnFinish` is set to `true` and cursor is on first element the previous one will be the last element on state, case value is set to `false` the previous element will be `null`.
     */
    prev() {
        if (this.hasPrev()) {
            if (this.lastCommand === 'next' && this.currentIndex === this.total() - 1) {
                this.lastCommand = 'prev';
                return this.items[this.currentIndex];
            }
            const prev = (this.currentIndex - 1);
            this.currentIndex = prev;
            this.lastCommand = this.returnCurrentOnReversion ? 'prev' : 'none';
            return this.items[prev];
        }
        ;
        if (!this.restartOnFinish)
            return null;
        this.toLast();
        return this.last();
    }
    /**
     * @description Get element.
     * @returns the first element on state.
     */
    first() {
        return this.items.at(0);
    }
    /**
     * @description Get element.
     * @returns the last element on state.
     */
    last() {
        return this.items.at(-1);
    }
    /**
     * @description Update cursor to the first element on state.
     * @returns instance of iterator.
     */
    toFirst() {
        if (this.currentIndex === 0 || this.currentIndex === -1) {
            this.currentIndex = -1;
            return this;
        }
        this.currentIndex = 0;
        return this;
    }
    /**
     * @description Update cursor to the last element on state.
     * @returns instance of iterator.
     */
    toLast() {
        if (this.currentIndex === this.total() - 1 || this.currentIndex === -1) {
            this.currentIndex = this.total();
            return this;
        }
        this.currentIndex = this.total() - 1;
        return this;
    }
    /**
     * @description Delete state. Remove all elements on state
     * @returns instance of iterator.
     */
    clear() {
        this.items.splice(0, this.total());
        this.currentIndex = -1;
        return this;
    }
    /**
     * @description Add new element to state after last position.
     * @param data as element.
     * @returns instance of iterator.
     */
    addToEnd(data) {
        this.items.push(data);
        return this;
    }
    /**
     * @description Add new element to state after last position.
     * @param data as element.
     * @returns instance of iterator.
     */
    add(data) {
        return this.addToEnd(data);
    }
    /**
     * @description Add new element to state before first position.
     * @param data as element.
     * @returns instance of iterator.
     */
    addToStart(data) {
        this.currentIndex = -1;
        this.items.unshift(data);
        return this;
    }
    /**
     * @description Remove the last element from state.
     * @returns instance of iterator.
     */
    removeLast() {
        if (this.currentIndex >= this.total())
            this.currentIndex -= 1;
        this.items.pop();
        return this;
    }
    /**
     * @description remove the first element from state.
     * @returns instance of iterator.
     */
    removeFirst() {
        if (this.currentIndex > 0)
            this.currentIndex -= 1;
        this.items.shift();
        return this;
    }
    /**
     * @description Create a new instance of Iterator and keep current state.
     * @returns a new instance of Iterator with state.
     */
    clone() {
        return Iterator.create({
            initialData: this.toArray(),
            restartOnFinish: this.restartOnFinish,
            returnCurrentOnReversion: this.returnCurrentOnReversion
        });
    }
    /**
     * @description Get elements on state as array.
     * @returns array of items on state.
     */
    toArray() {
        return [...this.items];
    }
    /**
     * @description Count total of items on state.
     * @returns total of items on state.
     */
    total() {
        return this.items.length;
    }
}
exports.Iterator = Iterator;
exports.default = Iterator;
//# sourceMappingURL=iterator.js.map