import { ICommand, IIterator, IResult, IResultExecute, IResultObject } from "../types";
/**
 * @summary The result is used to returns a operation result instead the own value.
 * @interface IResult<T, D, M>;
 * @classdesc on `T` refer to type of the value and `D` type of the error and `M` metaData type.
 * @default D is string.
 * @default M is empty object {}.
 */
export declare class Result<T = void, D = string, M = {}> implements IResult<T, D, M> {
    #private;
    private constructor();
    /**
     * @description Create an instance of Result as success state.
     * @returns instance of Result<void>.
     */
    static Ok(): Result<void>;
    /**
     * @description Create an instance of Result as success state.
     * @returns instance of Result<void>.
     */
    static Ok(): IResult<void>;
    /**
     * @description Create an instance of Result as success state with data and metadata to payload.
     * @param data as T to payload.
     * @param metaData as M to state.
     * @returns instance of Result.
     */
    static Ok<T, M = {}, D = string>(data: T, metaData?: M): Result<T, D, M>;
    /**
     * @description Create an instance of Result as success state with data and metadata to payload.
     * @param data as T to payload.
     * @param metaData as M to state.
     * @returns instance of Result.
     */
    static Ok<T, M = {}, D = string>(data: T, metaData?: M): IResult<T, D, M>;
    /**
     * @description Create an instance of Result as failure state with error and metadata to payload.
     * @param error as D to payload.
     * @param metaData as M to state.
     * @returns instance of Result.
     */
    static fail<D = string, M = {}, T = void>(error?: D, metaData?: M): Result<T, D, M>;
    /**
     * @description Create an instance of Iterator with array of Results on state.
     * @param results as array of Results
     * @returns instance of Iterator.
     */
    static iterate<A, B, M>(results?: Array<IResult<A, B, M>>): IIterator<IResult<A, B, M>>;
    /**
     * @description Check all results instances status. Returns the first failure or returns the first success one.
     * @param results arrays with results instance.
     * @returns instance of result.
     * @default returns failure if provide a empty array.
     */
    static combine<A = any, B = any, M = any>(results: Array<IResult<any, any, any>>): IResult<A, B, M>;
    /**
     * @description Execute any command on fail or success.
     * @param command instance of command that implements ICommand interface.
     * @returns Command result as payload.
     */
    execute<X, Y>(command: ICommand<X | void, Y>): IResultExecute<X, Y>;
    /**
     * @description Get the instance value.
     * @returns `data` T or `null` case result is failure.
     */
    value(): T;
    /**
     * @description Get the instance error.
     * @returns `error` D or `null` case result is success.
     */
    error(): D;
    /**
     * @description Check if result instance is failure.
     * @returns `true` case result instance failure or `false` case is success one.
     */
    isFail(): boolean;
    /**
     * @description Check if result instance is success.
     * @returns `true` case result instance success or `false` case is failure one.
     */
    isOk(): boolean;
    /**
     * @description Get the instance metadata.
     * @returns `metadata` M or `{}` result in case of empty object has no metadata value.
     */
    metaData(): M;
    /**
     * @description Get result state as object.
     * @returns result state.
     * @example
     * {
     * 	isOk: boolean;
     * 	isFail: boolean;
     * 	data: T | null;
     * 	error: D | null;
     * 	metaData: M | {};
     * }
     */
    toObject(): IResultObject<T, D, M>;
}
export default Result;
export declare const Combine: typeof Result.combine;
//# sourceMappingURL=result.d.ts.map