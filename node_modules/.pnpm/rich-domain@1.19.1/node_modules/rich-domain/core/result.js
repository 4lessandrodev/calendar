"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Result_isOk, _Result_isFail, _Result_data, _Result_error, _Result_metaData;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Combine = exports.Result = void 0;
const iterator_1 = require("./iterator");
/**
 * @summary The result is used to returns a operation result instead the own value.
 * @interface IResult<T, D, M>;
 * @classdesc on `T` refer to type of the value and `D` type of the error and `M` metaData type.
 * @default D is string.
 * @default M is empty object {}.
 */
class Result {
    constructor(isSuccess, data, error, metaData) {
        _Result_isOk.set(this, void 0);
        _Result_isFail.set(this, void 0);
        _Result_data.set(this, void 0);
        _Result_error.set(this, void 0);
        _Result_metaData.set(this, void 0);
        __classPrivateFieldSet(this, _Result_isOk, isSuccess, "f");
        __classPrivateFieldSet(this, _Result_isFail, !isSuccess, "f");
        __classPrivateFieldSet(this, _Result_data, data ?? null, "f");
        __classPrivateFieldSet(this, _Result_error, error ?? null, "f");
        __classPrivateFieldSet(this, _Result_metaData, metaData ?? {}, "f");
    }
    /**
     * @description Create an instance of Result as success state with data and metadata to payload.
     * @param data as T to payload.
     * @param metaData as M to state.
     * @returns instance of Result.
     */
    static Ok(data, metaData) {
        const _data = typeof data === 'undefined' ? null : data;
        const ok = new Result(true, _data, null, metaData);
        return Object.freeze(ok);
    }
    /**
     * @description Create an instance of Result as failure state with error and metadata to payload.
     * @param error as D to payload.
     * @param metaData as M to state.
     * @returns instance of Result.
     */
    static fail(error, metaData) {
        const _error = typeof error !== 'undefined' && error !== null ? error : 'void error. no message!';
        const fail = new Result(false, null, _error, metaData);
        return Object.freeze(fail);
    }
    /**
     * @description Create an instance of Iterator with array of Results on state.
     * @param results as array of Results
     * @returns instance of Iterator.
     */
    static iterate(results) {
        return iterator_1.default.create({ initialData: results, returnCurrentOnReversion: true });
    }
    /**
     * @description Check all results instances status. Returns the first failure or returns the first success one.
     * @param results arrays with results instance.
     * @returns instance of result.
     * @default returns failure if provide a empty array.
     */
    static combine(results) {
        const iterator = Result.iterate(results);
        if (iterator.isEmpty())
            return Result.fail('No results provided on combine param');
        while (iterator.hasNext()) {
            const currentResult = iterator.next();
            if (currentResult.isFail())
                return currentResult;
        }
        return iterator.first();
    }
    /**
     * @description Execute any command on fail or success.
     * @param command instance of command that implements ICommand interface.
     * @returns Command result as payload.
     */
    execute(command) {
        return {
            /**
             * @description Use this option the command does not require arguments.
             * @param option `Ok` or `fail`
             * @returns command payload or undefined.
             */
            on: (option) => {
                if (option === 'Ok' && this.isOk())
                    return command.execute();
                if (option === 'fail' && this.isFail())
                    return command.execute();
            },
            /**
             * @description Use this option the command require arguments.
             * @param data the same type your command require.
             * @returns on function.
             */
            withData: (data) => {
                return {
                    /**
                     * @description Use this option the command does not require arguments.
                     * @param option `Ok` or `fail`
                     * @returns command payload or undefined.
                     */
                    on: (option) => {
                        if (option === 'Ok' && this.isOk())
                            return command.execute(data);
                        if (option === 'fail' && this.isFail())
                            return command.execute(data);
                    }
                };
            }
        };
    }
    /**
     * @description Get the instance value.
     * @returns `data` T or `null` case result is failure.
     */
    value() {
        return __classPrivateFieldGet(this, _Result_data, "f");
    }
    /**
     * @description Get the instance error.
     * @returns `error` D or `null` case result is success.
     */
    error() {
        return __classPrivateFieldGet(this, _Result_error, "f");
    }
    /**
     * @description Check if result instance is failure.
     * @returns `true` case result instance failure or `false` case is success one.
     */
    isFail() {
        return __classPrivateFieldGet(this, _Result_isFail, "f");
    }
    /**
     * @description Check if result instance is success.
     * @returns `true` case result instance success or `false` case is failure one.
     */
    isOk() {
        return __classPrivateFieldGet(this, _Result_isOk, "f");
    }
    /**
     * @description Get the instance metadata.
     * @returns `metadata` M or `{}` result in case of empty object has no metadata value.
     */
    metaData() {
        const metaData = __classPrivateFieldGet(this, _Result_metaData, "f");
        return Object.freeze(metaData);
    }
    /**
     * @description Get result state as object.
     * @returns result state.
     * @example
     * {
     * 	isOk: boolean;
     * 	isFail: boolean;
     * 	data: T | null;
     * 	error: D | null;
     * 	metaData: M | {};
     * }
     */
    toObject() {
        const metaData = {
            isOk: __classPrivateFieldGet(this, _Result_isOk, "f"),
            isFail: __classPrivateFieldGet(this, _Result_isFail, "f"),
            data: __classPrivateFieldGet(this, _Result_data, "f"),
            error: __classPrivateFieldGet(this, _Result_error, "f"),
            metaData: __classPrivateFieldGet(this, _Result_metaData, "f")
        };
        return Object.freeze(metaData);
    }
}
exports.Result = Result;
_Result_isOk = new WeakMap(), _Result_isFail = new WeakMap(), _Result_data = new WeakMap(), _Result_error = new WeakMap(), _Result_metaData = new WeakMap();
exports.default = Result;
exports.Combine = Result.combine;
//# sourceMappingURL=result.js.map