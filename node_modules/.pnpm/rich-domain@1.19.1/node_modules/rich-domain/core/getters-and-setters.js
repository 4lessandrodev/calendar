"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GettersAndSetters = void 0;
const validator_1 = require("../utils/validator");
const util_1 = require("../utils/util");
const create_many_domain_instance_1 = require("./create-many-domain-instance");
const id_1 = require("./id");
/**
 * @description defines getter and setter to all domain instances.
 */
class GettersAndSetters {
    constructor(props, parentName, config) {
        this.props = props;
        this.validator = validator_1.default;
        this.util = util_1.default;
        this.parentName = 'ValueObject';
        this.config = { disableGetters: false, disableSetters: false };
        GettersAndSetters.validator = validator_1.default;
        GettersAndSetters.util = util_1.default;
        this.validator = validator_1.default;
        this.util = util_1.default;
        this.config.disableGetters = !!config?.disableGetters;
        this.config.disableSetters = !!config?.disableSetters;
        this.parentName = parentName;
    }
    /**
     * @description Create many domain instances
     * @param data Array of options
     * @returns data and result.
     * @summary result: final result of validating each instance
     * @summary data: all created instances as iterator of Result.
     * @callback Class you can use this function to create the args and define types to Props.
     *
     * @example
     *
     * const { result, data } = ValueObject.createMany([
     *   Class<AgeProps>(Age, props),
     *   Class<NameProps>(Name, props),
     *   Class<PriceProps>(Price, props)
     * ]);
     *
     * result.isOk() // true
     *
     * const age = data.next() as IResult<Age>;
     * const name = data.next() as IResult<Name>;
     * const price = data.next() as IResult<Price>;
     *
     * age.value().get('value') // 21
     *
     */
    static createMany(data) {
        return (0, create_many_domain_instance_1.default)(data);
    }
    /**
     * @description Validation used to `set` and `change` methods to validate value before set it.
     * @param _key prop key type
     * @param _value prop value type
     * @returns true if value is valid and false if is invalid.
     *
     *
     * @example
     * interface Props {
     *		value: string;
     *		age: number;
     *	};
     *
     *	class StringVo extends ValueObject<Props>{
     *		private constructor(props: Props) { super(props) }
     *
     *		validation<Key extends keyof Props>(value: Props[Key], key: Key): boolean {
     *
     *			const options: IPropsValidation<Props> = {
     *				value: (value: string) => value.length < 15,
     *				age: (value: number) => value > 0
     *			}
     *
     *			return options[key](value);
     *		};
     *
     *		public static create(props: Props): IResult<ValueObject<Props>, string> {
     *			return Result.Ok(new StringVo(props));
     *		}
     *	}
     */
    validation(_value, _key) { return true; }
    ;
    /**
     *
     * @param key the property key you want to get
     * @returns the value of property
     */
    get(key) {
        if (this.config.disableGetters) {
            console.log(`Trying to get key: "${String(key)}" but the getters are deactivated`);
            return null;
        }
        ;
        return this.props[key];
    }
    /**
     *
     * @param key the property you want to set.
     * @returns to function asking the value you want to set.
     */
    set(key) {
        return {
            /**
             * @description The value is only applied if pass on validation.
             * @param value the value you want to apply.
             * @param validation function to validate the value before apply. The value will be applied only if to pass on validation.
             * @example
             * (value: PropValue) => boolean;
             * @returns returns "true" if the value has changed and returns "false" if the value has not changed.
             */
            to: (value, validation) => {
                const instance = Reflect.getPrototypeOf(this);
                if (this.config.disableSetters) {
                    console.log(`Trying to set value: "${value}" for key: "${String(key)}" but, %c the setters are deactivated on ${instance?.constructor.name}`);
                    return false;
                }
                ;
                if (typeof validation === 'function') {
                    if (!validation(value)) {
                        console.log(`Trying to set value: "${value}" for key: "${String(key)}" but failed validation on ${instance?.constructor.name}`);
                        return false;
                    }
                    ;
                }
                const canUpdate = this.validation(value, key);
                if (!canUpdate) {
                    console.log(`Trying to set value: "${value}" for key: "${String(key)}" but failed validation on ${instance?.constructor.name}`);
                    return false;
                }
                if (key === 'id' && this.parentName === 'Entity') {
                    if (this.validator.isString(value) || this.validator.isNumber(value)) {
                        this['_id'] = id_1.default.create(value);
                        this['props']['id'] = this['_id'].value();
                        if (this.parentName === 'Entity') {
                            this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
                        }
                        return true;
                    }
                    if (this.validator.isID(value)) {
                        this['_id'] = value;
                        this['props']['id'] = this['_id'].value();
                        if (this.parentName === 'Entity') {
                            this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
                        }
                        return true;
                    }
                }
                this.props[key] = value;
                if (this.parentName === 'Entity') {
                    this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
                }
                return true;
            }
        };
    }
    /**
     *
     * @param key the property you want to set.
     * @param value the value to apply to the key.
     * @param validation function to validate the value before apply. The value will be applied only if to pass.
     * @returns returns "true" if the value has changed and returns "false" if the value has not changed.
     */
    change(key, value, validation) {
        const instance = Reflect.getPrototypeOf(this);
        if (this.config.disableSetters) {
            console.log(`Trying to set value: "${value}" for key: "${String(key)}" but the setters are deactivated on ${instance?.constructor.name}`);
            return false;
        }
        ;
        if (typeof validation === 'function') {
            if (!validation(value)) {
                console.log(`Trying to set value: "${value}" for key: "${String(key)}" but failed validation on ${instance?.constructor.name}`);
                return false;
            }
            ;
        }
        const canUpdate = this.validation(value, key);
        if (!canUpdate) {
            console.log(`Trying to set value: "${value}" for key: "${String(key)}" but failed validation on ${instance?.constructor.name}`);
            return false;
        }
        if (key === 'id' && this.parentName === 'Entity') {
            if (this.validator.isString(value) || this.validator.isNumber(value)) {
                this['_id'] = id_1.default.create(value);
                this['props']['id'] = this['_id'].value();
                if (this.parentName === 'Entity') {
                    this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
                }
                return true;
            }
            if (this.validator.isID(value)) {
                this['_id'] = value;
                this['props']['id'] = this['_id'].value();
                if (this.parentName === 'Entity') {
                    this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
                }
                return true;
            }
        }
        this.props[key] = value;
        if (this.parentName === 'Entity') {
            this['props'] = Object.assign({}, { ...this['props'] }, { updatedAt: new Date() });
        }
        return true;
    }
}
exports.GettersAndSetters = GettersAndSetters;
GettersAndSetters.validator = validator_1.default;
GettersAndSetters.util = util_1.default;
exports.default = GettersAndSetters;
//# sourceMappingURL=getters-and-setters.js.map