"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Validator = void 0;
const core_1 = require("../core");
class Validator {
    constructor() { }
    static create() {
        if (!Validator.instance) {
            Validator.instance = new Validator();
        }
        return Validator.instance;
    }
    static isSpecialChar(char, index) {
        const asciiCode = char.charCodeAt(index);
        return (asciiCode >= 33 && asciiCode <= 47 ||
            asciiCode >= 58 && asciiCode <= 64 ||
            asciiCode >= 91 && asciiCode <= 96 ||
            asciiCode >= 123 && asciiCode <= 126);
    }
    isArray(props) {
        return Array.isArray(props);
    }
    isString(props) {
        return typeof props === 'string';
    }
    isNumber(props) {
        return typeof props === 'number';
    }
    isDate(props) {
        return props instanceof Date;
    }
    isObject(props) {
        const isObj = typeof props === 'object';
        if (!isObj || props === null)
            return false;
        if (JSON.stringify(props) === JSON.stringify({}))
            return true;
        const hasKeys = Object.keys(props).length > 0;
        const isNotArray = !Validator.instance.isArray(props);
        const isNotEntity = !Validator.instance.isEntity(props);
        const isNotAggregate = !Validator.instance.isAggregate(props);
        const isNotValueObject = !Validator.instance.isValueObject(props);
        const isNotId = !Validator.instance.isID(props);
        return hasKeys && isNotAggregate && isNotArray && isNotEntity && isNotValueObject && isNotId;
    }
    isNull(props) {
        return props === null;
    }
    isUndefined(props) {
        return typeof props === 'undefined';
    }
    isBoolean(props) {
        return typeof props === 'boolean';
    }
    isFunction(props) {
        return typeof props === 'function';
    }
    isEntity(props) {
        const isEntity = props instanceof core_1.Entity;
        return !Validator.instance.isAggregate(props) && isEntity;
    }
    isAggregate(props) {
        return props instanceof core_1.Aggregate;
    }
    isValueObject(props) {
        return props instanceof core_1.ValueObject;
    }
    isSymbol(props) {
        return typeof props === 'symbol';
    }
    isID(props) {
        return props instanceof core_1.ID;
    }
    number(target) {
        return {
            isEqualTo: (value) => Validator.instance.isNumber(target) && Validator.instance.isNumber(value) && target === value,
            isGreaterThan: (value) => Validator.instance.isNumber(target) && Validator.instance.isNumber(value) && target > value,
            isLessThan: (value) => Validator.instance.isNumber(target) && Validator.instance.isNumber(value) && target < value,
            isLessOrEqualTo: (value) => Validator.instance.isNumber(target) &&
                Validator.instance.isNumber(value) && target <= value,
            isGreaterOrEqualTo: (value) => Validator.instance.isNumber(target) &&
                Validator.instance.isNumber(value) && target >= value,
            isSafeInteger: () => Validator.instance.isNumber(target) &&
                target <= Number.MAX_SAFE_INTEGER && target >= Number.MIN_SAFE_INTEGER,
            isPositive: () => Validator.instance.isNumber(target) && target >= 0,
            isNegative: () => Validator.instance.isNumber(target) && target < 0,
            isEven: () => Validator.instance.isNumber(target) && target % 2 === 0,
            isInteger: () => Validator.instance.isNumber(target) && target - Math.trunc(target) === 0,
            isBetween: (min, max) => Validator.instance.isNumber(target) && target < max && target > min,
            isBetweenOrEqual: (min, max) => Validator.instance.isNumber(target) && target <= max && target >= min
        };
    }
    string(target) {
        return {
            isSpecialChar: (index = 0) => Validator.instance.isString(target[index]) && Validator.isSpecialChar(target, index),
            hasSpecialChar: () => Validator.instance.isString(target) && target.split('').map((char) => Validator.isSpecialChar(char, 0)).includes(true),
            hasLengthGreaterThan: (length) => Validator.instance.isString(target) && target.length > length,
            hasLengthGreaterOrEqualTo: (length) => Validator.instance.isString(target) && target.length >= length,
            hasLengthLessThan: (length) => Validator.instance.isString(target) && target.length < length,
            hasLengthLessOrEqualTo: (length) => Validator.instance.isString(target) && target.length <= length,
            hasLengthEqualTo: (length) => Validator.instance.isString(target) && target.length === length,
            hasLengthBetween: (min, max) => Validator.instance.isString(target) &&
                target.length > min && target.length < max,
            hasLengthBetweenOrEqual: (min, max) => Validator.instance.isString(target) &&
                target.length >= min && target.length <= max,
            includes: (value) => Validator.instance.isString(target) && target.includes(value) || value.split('').map((char) => target.includes(char)).includes(true),
            isEmpty: () => (Validator.instance.isUndefined(target) ||
                Validator.instance.isNull(target)) ||
                (Validator.instance.isString(target) &&
                    target.trim() === ''),
            match: (regex) => regex.test(target),
            hasOnlyNumbers: () => Validator.instance.isString(target) &&
                target.split('')
                    .map((n) => n.charCodeAt(0) >= 48 && n.charCodeAt(0) <= 57)
                    .every((v) => v === true),
            hasOnlyLetters: () => Validator.instance.isString(target) &&
                target.toUpperCase()
                    .split('')
                    .map((n) => n.charCodeAt(0) >= 65 && n.charCodeAt(0) <= 90)
                    .every((v) => v === true),
            isEqual: (value) => Validator.instance.isString(target) && Validator.instance.isString(value) && target === value
        };
    }
    date(target) {
        return {
            isBeforeThan: (value) => (Validator.instance.isDate(target) &&
                Validator.instance.isDate(value)) && target.getTime() < value.getTime(),
            isBeforeOrEqualTo: (value) => (Validator.instance.isDate(target) &&
                Validator.instance.isDate(value)) && target.getTime() <= value.getTime(),
            isAfterNow: () => Validator.instance.isDate(target) && target.getTime() > Date.now(),
            isBeforeNow: () => Validator.instance.isDate(target) && target.getTime() < Date.now(),
            isBetween: (start, end) => Validator.instance.isDate(target) &&
                target.getTime() > start.getTime() &&
                target.getTime() < end.getTime(),
            isWeekend: () => Validator.instance.isDate(target) && target.getDay() === 0 ||
                Validator.instance.isDate(target) && target.getDay() === 6,
            isAfterThan: (value) => (Validator.instance.isDate(target) &&
                Validator.instance.isDate(value)) && target.getTime() > value.getTime(),
            isAfterOrEqualTo: (value) => (Validator.instance.isDate(target) &&
                Validator.instance.isDate(value)) && target.getTime() >= value.getTime(),
        };
    }
}
exports.Validator = Validator;
Validator.instance = null;
exports.default = Validator.create();
//# sourceMappingURL=validator.js.map